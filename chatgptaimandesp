-- CameraLock_Obsidian_LocalScript.lua
-- Studio / Private use ONLY. Do NOT use to gain unfair advantage in live multiplayer games.
-- Put this LocalScript into StarterPlayer > StarterPlayerScripts (client-side).
-- Optional: supply a circular PNG asset id to VisualFOVImageAssetId to show an on-screen FOV circle.
-- Features:
--  • Draggable toggle ImageButton with ON/OFF label (Obsidian-style look can be achieved by replacing images/styles)
--  • Customizable FOV (degrees)
--  • Finds players whose head is inside FOV and line-of-sight (raycast) and locks camera to their head
--  • Stops locking when the targeted player's Humanoid dies
--  • Strictly client-side; intended for Studio testing / recording / consenting players.

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local Workspace = game:GetService("Workspace")

local localPlayer = Players.LocalPlayer
local camera = Workspace.CurrentCamera

-- ======= CONFIG =======
local CONFIG = {
    FOV_DEGREES = 30,                -- angular radius in degrees for the FOV cone
    SEARCH_DISTANCE = 200,           -- max distance to consider targets
    CAMERA_BACKOFF = 5,              -- how many studs behind the head to place the camera
    SMOOTH_SPEED = 12,               -- higher = snappier
    VISUAL_FOV_ASSET = 137322132382651,          -- set to an asset id string e.g. "rbxassetid://123456" to show a circle image
    TOGGLE_IMAGE_ASSET = 11353098069,        -- optional Image asset for the draggable toggle button
}

-- ======= GUI SETUP =======
local screenGui = Instance.new("ScreenGui")
screenGui.Name = "CameraLockUI"
screenGui.ResetOnSpawn = false
screenGui.Parent = localPlayer:WaitForChild("PlayerGui")

-- Toggle button (ImageButton so it's draggable and styled)
local toggleBtn = Instance.new("ImageButton")
toggleBtn.Name = "CameraLockToggle"
toggleBtn.Size = UDim2.new(0, 90, 0, 34)
toggleBtn.Position = UDim2.new(0, 20, 0, 80)
toggleBtn.AnchorPoint = Vector2.new(0,0)
toggleBtn.BackgroundTransparency = 0.15
toggleBtn.BackgroundColor3 = Color3.fromRGB(30,30,30)
toggleBtn.BorderSizePixel = 0
if CONFIG.TOGGLE_IMAGE_ASSET then
    toggleBtn.Image = CONFIG.TOGGLE_IMAGE_ASSET
else
    toggleBtn.Image = ""
end

-- Label inside button
local label = Instance.new("TextLabel")
label.Name = "StateLabel"
label.Size = UDim2.new(1, -8, 1, -8)
label.Position = UDim2.new(0, 4, 0, 4)
label.BackgroundTransparency = 1
label.Text = "OFF"
label.Font = Enum.Font.GothamBold
label.TextSize = 14
label.TextColor3 = Color3.fromRGB(220,220,220)
label.TextXAlignment = Enum.TextXAlignment.Center
label.TextYAlignment = Enum.TextYAlignment.Center
label.Parent = toggleBtn

-- Small subtitle for FOV config (click to open simple config)
local sub = Instance.new("TextLabel")
sub.Name = "FOVLabel"
sub.Size = UDim2.new(0, 140, 0, 24)
sub.Position = UDim2.new(0, 20 + 100, 0, 80)
sub.BackgroundTransparency = 0.15
sub.BackgroundColor3 = Color3.fromRGB(24,24,24)
sub.BorderSizePixel = 0
sub.Text = string.format("FOV: %d°", CONFIG.FOV_DEGREES)
sub.Font = Enum.Font.Gotham
sub.TextSize = 13
sub.TextColor3 = Color3.fromRGB(200,200,200)
sub.Parent = screenGui

-- Optional visual FOV (requires asset). If you set CONFIG.VISUAL_FOV_ASSET to an image that's a circle with transparent background
local visualFOV
if CONFIG.VISUAL_FOV_ASSET then
    visualFOV = Instance.new("ImageLabel")
    visualFOV.Name = "FOVCircle"
    visualFOV.Size = UDim2.new(0, 300, 0, 300)
    visualFOV.AnchorPoint = Vector2.new(0.5, 0.5)
    visualFOV.Position = UDim2.new(0.5, 0, 0.5, 0)
    visualFOV.BackgroundTransparency = 1
    visualFOV.Image = CONFIG.VISUAL_FOV_ASSET
    visualFOV.Parent = screenGui
end

-- Make toggle draggable
local dragging = false
local dragStart, startPos

local function updateDrag(input)
    if not dragging then return end
    local delta = input.Position - dragStart
    toggleBtn.Position = UDim2.new(0, math.clamp(startPos.X + delta.X, 0, workspace.CurrentCamera.ViewportSize.X - toggleBtn.AbsoluteSize.X), 0, math.clamp(startPos.Y + delta.Y, 0, workspace.CurrentCamera.ViewportSize.Y - toggleBtn.AbsoluteSize.Y))
    sub.Position = UDim2.new(0, toggleBtn.Position.X.Offset + 100, 0, toggleBtn.Position.Y.Offset)
end

toggleBtn.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 then
        dragging = true
        dragStart = input.Position
        startPos = Vector2.new(toggleBtn.Position.X.Offset, toggleBtn.Position.Y.Offset)
        input.Changed:Connect(function()
            if input.UserInputState == Enum.UserInputState.End then
                dragging = false
            end
        end)
    end
end)

UserInputService.InputChanged:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseMovement then
        updateDrag(input)
    elseif input.UserInputType == Enum.UserInputType.Touch then
        updateDrag(input)
    end
end)

-- Simple left-click toggling
local enabled = false
local function setEnabled(val)
    enabled = val
    label.Text = enabled and "ON" or "OFF"
    if enabled then
        label.TextColor3 = Color3.fromRGB(120, 255, 120)
    else
        label.TextColor3 = Color3.fromRGB(220,220,220)
    end
end

toggleBtn.MouseButton1Click:Connect(function()
    setEnabled(not enabled)
end)

-- Small clickable area to change FOV (cycles values)
local FOV_VALUES = {10, 20, 30, 45, 60, 90}
local fovIndex = 3 -- default index for 30 degrees
sub.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 then
        fovIndex = fovIndex % #FOV_VALUES + 1
        CONFIG.FOV_DEGREES = FOV_VALUES[fovIndex]
        sub.Text = string.format("FOV: %d°", CONFIG.FOV_DEGREES)
        if visualFOV then
            -- adjust visual size roughly proportional to FOV
            local size = math.clamp(CONFIG.FOV_DEGREES * 4, 80, 600)
            visualFOV.Size = UDim2.new(0, size, 0, size)
        end
    end
end)

-- ======= CORE LOGIC =======

local function isAlive(character)
    if not character then return false end
    local humanoid = character:FindFirstChildOfClass("Humanoid")
    return humanoid and humanoid.Health > 0
end

local function getHead(player)
    if not player or not player.Character then return nil end
    local head = player.Character:FindFirstChild("Head")
    if head and head:IsA("BasePart") then return head end
    return nil
end

local function unitAngleBetween(vecA, vecB)
    local a = vecA.Unit
    local b = vecB.Unit
    local dot = math.clamp(a:Dot(b), -1, 1)
    return math.deg(math.acos(dot))
end

local function hasLineOfSight(fromPos, toPos, ignoreList)
    local params = RaycastParams.new()
    params.FilterType = Enum.RaycastFilterType.Blacklist
    params.FilterDescendantsInstances = ignoreList or {}
    params.IgnoreWater = true
    local direction = toPos - fromPos
    local result = Workspace:Raycast(fromPos, direction, params)
    if result then
        -- if the first thing hit is the target part itself (or descendant), it's visible
        -- otherwise it's blocked
        return false, result
    end
    return true, nil
end

-- Helper: find best target in FOV
local function findTarget()
    if not camera or not camera.CameraType then return nil end
    local camPos = camera.CFrame.Position
    local camLook = camera.CFrame.LookVector

    local best, bestAng, bestDist
    for _, pl in pairs(Players:GetPlayers()) do
        if pl ~= localPlayer and pl.Character and isAlive(pl.Character) then
            local head = getHead(pl)
            if head then
                local toHead = head.Position - camPos
                local dist = toHead.Magnitude
                if dist <= CONFIG.SEARCH_DISTANCE then
                    local ang = unitAngleBetween(camLook, toHead)
                    if ang <= CONFIG.FOV_DEGREES then
                        -- raycast to check LOS; ignore local player and target character when doing raycast? we want to detect obstacles between camera and head
                        local ignore = {localPlayer.Character, pl.Character}
                        local visible = hasLineOfSight(camPos, head.Position, ignore)
                        if visible then
                            if not best or ang < bestAng then
                                best = pl
                                bestAng = ang
                                bestDist = dist
                            end
                        end
                    end
                end
            end
        end
    end
    return best
end

-- Active camera lock state
local currentTarget
local connectionRender
local function releaseCamera()
    if connectionRender then
        connectionRender:Disconnect()
        connectionRender = nil
    end
    if camera then
        camera.CameraType = Enum.CameraType.Custom
    end
    currentTarget = nil
end

local function lockToTarget(player)
    if not player or not player.Character then return end
    local head = getHead(player)
    if not head then return end
    local humanoid = player.Character:FindFirstChildOfClass("Humanoid")
    if not humanoid then return end

    -- set camera scriptable
    camera.CameraType = Enum.CameraType.Scriptable
    currentTarget = player

    -- listen for death
    local diedConn
    diedConn = humanoid.Died:Connect(function()
        diedConn:Disconnect()
        releaseCamera()
    end)

    -- render loop: smoothly position camera behind the head and look at it
    local lastCFrame = camera.CFrame
    connectionRender = RunService.RenderStepped:Connect(function(dt)
        if not enabled then
            diedConn:Disconnect()
            releaseCamera()
            return
        end
        if not player.Parent or not isAlive(player.Character) then
            diedConn:Disconnect()
            releaseCamera()
            return
        end
        local headPart = getHead(player)
        if not headPart then return end

        -- check LOS each frame (cheap) - if blocked, release
        local visible = hasLineOfSight(camera.CFrame.Position, headPart.Position, {localPlayer.Character, player.Character})
        if not visible then
            -- no LOS -> release camera (it will attempt to find next target)
            diedConn:Disconnect()
            releaseCamera()
            return
        end

        -- desired camera position: behind the head by CAMERA_BACKOFF along the head's look vector
        local back = headPart.CFrame.LookVector * -CONFIG.CAMERA_BACKOFF
        local desiredPos = headPart.Position + Vector3.new(0, 0.5, 0) + back
        local desiredCFrame = CFrame.new(desiredPos, headPart.Position + Vector3.new(0, 0.5, 0))

        -- smooth interp
        local alpha = math.clamp(CONFIG.SMOOTH_SPEED * dt, 0, 1)
        local newCFrame = lastCFrame:Lerp(desiredCFrame, alpha)
        camera.CFrame = newCFrame
        lastCFrame = newCFrame
    end)
end


-- Main loop: when enabled search for a target in FOV and lock
RunService.Heartbeat:Connect(function()
    if not enabled then
        if currentTarget then
            releaseCamera()
        end
        return
    end

    -- if already locked to a valid target, nothing to do
    if currentTarget and currentTarget.Character and isAlive(currentTarget.Character) then
        return
    end

    -- find new target
    local target = findTarget()
    if target then
        lockToTarget(target)
    end
end)

-- Clean up when local player leaves
localPlayer.OnTeleport:Connect(function(state)
    releaseCamera()
end)

-- Initialize visuals if any
if visualFOV then
    visualFOV.Visible = true
    local size = math.clamp(CONFIG.FOV_DEGREES * 4, 80, 600)
    visualFOV.Size = UDim2.new(0, size, 0, size)
    visualFOV.AnchorPoint = Vector2.new(0.5, 0.5)
    visualFOV.Position = UDim2.new(0.5, 0.5)
end

-- Final note: This script is intentionally client-side and designed for Studio/consensual use only.
-- Replace the GUI styling with your Obsidian components if you want a native Obsidian look — the logic
-- for FOV, raycast LOS, and camera control is self-contained and safe to integrate into your UI framework.

print("CameraLock UI loaded. Click the toggle to enable.")

FOV_Circle.Radius = FOV_Radius
FOV_Circle.Visible = true

local ESP_Boxes = {}

--// Create UI Tabs
local MainTab = Window:CreateTab("Main", 4483362458)
local VisualsTab = Window:CreateTab("Visuals", 4483362458)

--// Controls
MainTab:CreateToggle({
    Name = "Enable Camera Lock",
    CurrentValue = false,
    Flag = "LockEnabled",
    Callback = function(Value)
        LockEnabled = Value
    end
})

VisualsTab:CreateToggle({
    Name = "Enable ESP",
    CurrentValue = true,
    Flag = "ESPEnabled",
    Callback = function(Value)
        ESP_Enabled = Value
    end
})

VisualsTab:CreateSlider({
    Name = "FOV Radius",
    Range = {25, 300},
    Increment = 5,
    CurrentValue = FOV_Radius,
    Flag = "FOVRadius",
    Callback = function(Value)
        FOV_Radius = Value
        FOV_Circle.Radius = Value
    end
})

--// ESP Functions
local function createESP(plr)
    local box = Drawing.new("Square")
    box.Thickness = 1
    box.Filled = false
    box.Color = Color3.fromRGB(0, 255, 0)
    box.Transparency = 0.9
    ESP_Boxes[plr] = box
end

local function removeESP(plr)
    if ESP_Boxes[plr] then
        ESP_Boxes[plr]:Remove()
        ESP_Boxes[plr] = nil
    end
end

for _, plr in pairs(game.Players:GetPlayers()) do
    if plr ~= Player then
        createESP(plr)
    end
end

game.Players.PlayerAdded:Connect(function(plr)
    if plr ~= Player then
        createESP(plr)
    end
end)

game.Players.PlayerRemoving:Connect(removeESP)

--// Get Closest Player in FOV
local function getClosestInFOV()
    local closest = nil
    local shortest = math.huge

    for _, plr in pairs(game.Players:GetPlayers()) do
        if plr ~= Player and plr.Character and plr.Character:FindFirstChild("Head") then
            local headPos, onScreen = Camera:WorldToViewportPoint(plr.Character.Head.Position)
            if onScreen then
                local center = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)
                local dist = (Vector2.new(headPos.X, headPos.Y) - center).Magnitude
                if dist <= FOV_Radius and dist < shortest then
                    shortest = dist
                    closest = plr
                end
            end
        end
    end
    return closest
end

--// Check if Target is Visible
local function isVisible(target)
    local head = target.Character:FindFirstChild("Head")
    if not head then return false end

    -- Raycast to see if the head is visible
    local ray = Ray.new(Camera.CFrame.Position, head.Position - Camera.CFrame.Position)
    local hitPart = workspace:FindPartOnRay(ray, Player.Character, false, true)
    
    return hitPart == head
end

--// Main Render Loop
RunService.RenderStepped:Connect(function()
    -- FOV Circle
    local center = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)
    FOV_Circle.Position = center
    FOV_Circle.Visible = true

    -- ESP Update
    for plr, box in pairs(ESP_Boxes) do
        if plr.Character and plr.Character:FindFirstChild("HumanoidRootPart") then
            local root = plr.Character.HumanoidRootPart
            local head = plr.Character:FindFirstChild("Head")
            local rootPos, onScreen = Camera:WorldToViewportPoint(root.Position)
            local headPos = Camera:WorldToViewportPoint(head.Position)

            if onScreen and ESP_Enabled then
                local scale = 1 / headPos.Z * 1000
                local size = Vector2.new(30 * scale, 40 * scale)
                local position = Vector2.new(rootPos.X - size.X / 2, rootPos.Y - size.Y / 2)
                box.Size = size
                box.Position = position
                box.Visible = true
            else
                box.Visible = false
            end
        else
            box.Visible = false
        end
    end

    -- Camera Lock (Aimbot with Visibility Check)
    if LockEnabled then
        local closest = getClosestInFOV()
        if closest and closest.Character and closest.Character:FindFirstChild("Head") then
            if isVisible(closest) then
                TargetPlayer = closest
                Camera.CFrame = CFrame.new(Camera.CFrame.Position, TargetPlayer.Character.Head.Position)
            end
        end
    end
end)
FOV_Circle.Radius = FOV_Radius
FOV_Circle.Visible = true

local ESP_Boxes = {}

--// Create UI Tabs
local MainTab = Window:CreateTab("Main", 4483362458)
local VisualsTab = Window:CreateTab("Visuals", 4483362458)

--// Controls
MainTab:CreateToggle({
    Name = "Enable Camera Lock",
    CurrentValue = false,
    Flag = "LockEnabled",
    Callback = function(Value)
        LockEnabled = Value
    end
})

VisualsTab:CreateToggle({
    Name = "Enable ESP",
    CurrentValue = true,
    Flag = "ESPEnabled",
    Callback = function(Value)
        ESP_Enabled = Value
    end
})

VisualsTab:CreateSlider({
    Name = "FOV Radius",
    Range = {25, 300},
    Increment = 5,
    CurrentValue = FOV_Radius,
    Flag = "FOVRadius",
    Callback = function(Value)
        FOV_Radius = Value
        FOV_Circle.Radius = Value
    end
})

--// ESP Functions
local function createESP(plr)
    local box = Drawing.new("Square")
    box.Thickness = 1
    box.Filled = false
    box.Color = Color3.fromRGB(0, 255, 0)
    box.Transparency = 0.9
    ESP_Boxes[plr] = box
end

local function removeESP(plr)
    if ESP_Boxes[plr] then
        ESP_Boxes[plr]:Remove()
        ESP_Boxes[plr] = nil
    end
end

for _, plr in pairs(game.Players:GetPlayers()) do
    if plr ~= Player then
        createESP(plr)
    end
end

game.Players.PlayerAdded:Connect(function(plr)
    if plr ~= Player then
        createESP(plr)
    end
end)

game.Players.PlayerRemoving:Connect(removeESP)

--// Get Closest Player in FOV
local function getClosestInFOV()
    local closest = nil
    local shortest = math.huge

    for _, plr in pairs(game.Players:GetPlayers()) do
        if plr ~= Player and plr.Character and plr.Character:FindFirstChild("Head") then
            local headPos, onScreen = Camera:WorldToViewportPoint(plr.Character.Head.Position)
            if onScreen then
                local center = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)
                local dist = (Vector2.new(headPos.X, headPos.Y) - center).Magnitude
                if dist <= FOV_Radius and dist < shortest then
                    shortest = dist
                    closest = plr
                end
            end
        end
    end
    return closest
end

--// Main Render Loop
RunService.RenderStepped:Connect(function()
    -- FOV Circle
    local center = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)
    FOV_Circle.Position = center
    FOV_Circle.Visible = true

    -- ESP Update
    for plr, box in pairs(ESP_Boxes) do
        if plr.Character and plr.Character:FindFirstChild("HumanoidRootPart") then
            local root = plr.Character.HumanoidRootPart
            local head = plr.Character:FindFirstChild("Head")
            local rootPos, onScreen = Camera:WorldToViewportPoint(root.Position)
            local headPos = Camera:WorldToViewportPoint(head.Position)

            if onScreen and ESP_Enabled then
                local scale = 1 / headPos.Z * 1000
                local size = Vector2.new(30 * scale, 40 * scale)
                local position = Vector2.new(rootPos.X - size.X / 2, rootPos.Y - size.Y / 2)
                box.Size = size
                box.Position = position
                box.Visible = true
            else
                box.Visible = false
            end
        else
            box.Visible = false
        end
    end

    -- Camera Lock
    if LockEnabled then
        local closest = getClosestInFOV()
        if closest and closest.Character and closest.Character:FindFirstChild("Head") then
            TargetPlayer = closest
            Camera.CFrame = CFrame.new(Camera.CFrame.Position, TargetPlayer.Character.Head.Position)
        end
    end
end)
Window:CreateSlider({
    Name = "FOV Radius",
    Range = {25, 250},
    Increment = 5,
    CurrentValue = FOV_Radius,
    Flag = "FOVRadius",
    Callback = function(Value)
        FOV_Radius = Value
        FOV_Circle.Radius = Value
    end
})

Window:CreateToggle({
    Name = "Enable ESP",
    CurrentValue = ESP_Enabled,
    Flag = "ESPEnabled",
    Callback = function(Value)
        ESP_Enabled = Value
    end
})

Window:CreateToggle({
    Name = "Enable Camera Lock",
    CurrentValue = LockEnabled,
    Flag = "LockEnabled",
    Callback = function(Value)
        LockEnabled = Value
    end
})

--// ESP Box Drawing Storage
local ESP_Boxes = {}

--// Create ESP Box
local function createESP(player)
    local box = Drawing.new("Square")
    box.Thickness = 1
    box.Filled = false
    box.Color = Color3.fromRGB(0, 255, 0)
    box.Transparency = 0.9
    ESP_Boxes[player] = box
end

--// Remove ESP Box
local function removeESP(player)
    if ESP_Boxes[player] then
        ESP_Boxes[player]:Remove()
        ESP_Boxes[player] = nil
    end
end

--// Handle Player Join/Leave
for _, plr in pairs(game.Players:GetPlayers()) do
    if plr ~= Player then
        createESP(plr)
    end
end

game.Players.PlayerAdded:Connect(function(plr)
    if plr ~= Player then
        createESP(plr)
    end
end)

game.Players.PlayerRemoving:Connect(removeESP)

--// Get Closest Player Inside FOV
local function getClosestInFOV()
    local closest = nil
    local shortest = math.huge

    for _, plr in pairs(game.Players:GetPlayers()) do
        if plr ~= Player and plr.Character and plr.Character:FindFirstChild("Head") then
            local headPos, onScreen = Camera:WorldToViewportPoint(plr.Character.Head.Position)
            if onScreen then
                local mousePos = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)
                local dist = (Vector2.new(headPos.X, headPos.Y) - mousePos).Magnitude
                if dist <= FOV_Radius and dist < shortest then
                    shortest = dist
                    closest = plr
                end
            end
        end
    end
    return closest
end

--// Update Loop
RunService.RenderStepped:Connect(function()
    -- Update FOV Circle Position
    local mousePos = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)
    FOV_Circle.Position = mousePos
    FOV_Circle.Visible = true

    -- Update ESP Boxes
    for plr, box in pairs(ESP_Boxes) do
        if plr.Character and plr.Character:FindFirstChild("HumanoidRootPart") then
            local root = plr.Character.HumanoidRootPart
            local head = plr.Character:FindFirstChild("Head")
            local hrpPos, vis = Camera:WorldToViewportPoint(root.Position)
            local headPos, vis2 = Camera:WorldToViewportPoint(head.Position)

            if vis and vis2 and ESP_Enabled then
                local scale = 1 / (headPos.Z) * 1000
                local boxSize = Vector2.new(30 * scale, 40 * scale)
                local boxPos = Vector2.new(hrpPos.X - boxSize.X / 2, hrpPos.Y - boxSize.Y / 2)

                box.Size = boxSize
                box.Position = boxPos
                box.Visible = true
            else
                box.Visible = false
            end
        else
            box.Visible = false
        end
    end

    -- Camera Lock Logic
    if LockEnabled then
        local closest = getClosestInFOV()
        if closest and closest.Character and closest.Character:FindFirstChild("Head") then
            TargetPlayer = closest
            Camera.CFrame = CFrame.new(Camera.CFrame.Position, TargetPlayer.Character.Head.Position)
        end
    end
end)
